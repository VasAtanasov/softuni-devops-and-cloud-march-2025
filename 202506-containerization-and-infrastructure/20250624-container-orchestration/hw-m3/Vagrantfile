# -*- mode: ruby -*-
# vi: set ft=ruby :
require 'ipaddr'

# ---------------- Settings ----------------
SETTINGS = {
  # BOX_NAME: 'shekeriev/debian-12.11',
  BOX_NAME: 'debian-docker',
  MEMORY: 2048,
  CPUS: 1,
  SUBNET: '192.168.10.0/24',
  MANAGERS: 1,
  WORKERS: 2,
  SHARED_DIR: '/vagrant'
}

ASSETS = File.join(File.dirname(__FILE__), 'assets')
TOTAL = SETTINGS[:MANAGERS] + SETTINGS[:WORKERS]
IP_START = 201
DEBUG = ENV['DEBUG'] == 'true'
LEADER_INDEX = 0

puts '[INFO] DEBUG MODE ENABLED' if DEBUG

# ---------------- Helpers ----------------
def ips(subnet, start, count)
  base = IPAddr.new(subnet).to_range.first.to_s.split('.')
  (start...(start + count)).map { |i| (base[0..2] + [i]).join('.') }
end

def host_entries(role, count, offset, ips)
  (1..count).map { |i| "#{ips[offset + i - 1]} #{role}#{i}.do1.hw #{role}#{i}" }
end

ips_list = ips(SETTINGS[:SUBNET], IP_START, TOTAL)
hosts = host_entries('manager', SETTINGS[:MANAGERS], 0, ips_list) +
        host_entries('worker', SETTINGS[:WORKERS], SETTINGS[:MANAGERS], ips_list)

# ---------------- Vagrant Config ----------------
Vagrant.configure('2') do |config|

  # config.vm.provision :shell, path: 'docker-setup.sh'

  config.vm.provision :file, source: "#{ASSETS}/logo", destination: '/tmp/logo'

  config.vm.provision :shell, inline: <<~EOS
    echo "* Add hosts ..."
    #{hosts.map { |entry| "echo '#{entry}' >> /etc/hosts" }.join("\n")}

    echo "* Install Additional Packages ..."
    echo "* Installing tools ..."
    apt-get update -qq
    DEBIAN_FRONTEND=noninteractive apt-get install -y -qq jq yq tree git vim tmux

    echo "* Disable login message..."
    echo -n > /home/vagrant/.hushlogin

    echo "* Setting greeting..."
    GREETING_FILE=/etc/profile.d/greeting.sh
    [ -f "$GREETING_FILE" ] || cp /tmp/logo "$GREETING_FILE"
  EOS

  config.vm.provider :virtualbox do |vb|
    vb.customize ['modifyvm', :id, '--memory', SETTINGS[:MEMORY]]
    vb.customize ['modifyvm', :id, '--cpus', SETTINGS[:CPUS]]
    vb.customize ['modifyvm', :id, '--groups', '/swarm']
  end

  config.vm.network :forwarded_port, guest: 9443, host: 9443, auto_correct: true
  config.vm.network :forwarded_port, guest: 3306, host: 3306, auto_correct: true

  # ---------------- Define Manager Nodes ----------------
  SETTINGS[:MANAGERS].times do |i|
    name = "manager#{i + 1}"
    ip = ips_list[i]
    puts "#{ip} #{name}" if DEBUG

    config.vm.define name do |manager|
      manager.vm.box = SETTINGS[:BOX_NAME]
      manager.vm.network :private_network, ip: ip
      manager.vm.hostname = "#{name}.local"

      manager.vm.provider :virtualbox do |vb|
        vb.name = name
      end

      manager.vm.provision 'Init docker swarm', type: :shell do |shell|
        shell.inline = "docker swarm init --advertise-addr #{ip}"
      end if i == LEADER_INDEX

      manager.vm.provision 'Add labels to manager node', type: :shell do |shell|
        shell.inline = <<~SCRIPT
          docker node update --label-add registry=true #{name}
          docker node update --label-add role=manager #{name}
        SCRIPT
      end

      manager.vm.provision 'Extract worker token', type: :shell do |shell|
        puts "Saving worker token at #{SETTINGS[:SHARED_DIR]}/worker.token" if DEBUG
        shell.inline = "docker swarm join-token -q worker > #{SETTINGS[:SHARED_DIR]}/worker.token"
      end if i == LEADER_INDEX

      manager.vm.provision 'Extract manager token', type: "shell" do |shell|
        puts "Saving manager token at #{SETTINGS[:SHARED_DIR]}/manager.token" if DEBUG
        shell.inline = "docker swarm join-token -q manager > #{SETTINGS[:SHARED_DIR]}/manager.token"
      end if i == LEADER_INDEX

      manager.vm.provision 'Create local docker registry', type: :shell do |shell|
        port = 5000 + i
        puts "Create docker registry on #{name}:#{port}" if DEBUG
        manager.vm.network :forwarded_port, guest: port, host: port
        shell.inline = <<~SCRIPT
          docker service create \
            --detach=true \
            --name registry \
            --publish published=#{port},target=5000 \
            --constraint 'node.role==manager' \
            registry:2
        SCRIPT
      end if i == LEADER_INDEX

      manager.vm.provision 'Visualizer', type: :shell do |shell|
        port = 8080
        puts "Running visualiser on port #{port}" if DEBUG
        manager.vm.network :forwarded_port, guest: port, host: port
        shell.inline = <<~SCRIPT
          docker service create \
            --detach=true \
            --name=viz \
            --publish=#{port}:#{port}/tcp \
            --constraint=node.role==manager \
            --mount=type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
            dockersamples/visualizer
        SCRIPT
      end if i == LEADER_INDEX

      manager.vm.provision 'Portainer for Docker Swarm', type: :shell do |shell|
        puts "Running portainer stack" if DEBUG
        shell.inline = <<~SCRIPT
          curl -sSL https://downloads.portainer.io/ce-lts/portainer-agent-stack.yml -o portainer-agent-stack.yml
          docker stack deploy -c portainer-agent-stack.yml portainer
        SCRIPT
      end if i == LEADER_INDEX

      manager.vm.provision 'Join manager to swarm', type: :shell do |shell|
        puts "Joining #{name} to docker swarm" if DEBUG
        shell.inline = <<~SCRIPT
          docker swarm join --token $(cat #{SETTINGS[:SHARED_DIR]}/manager.token) --advertise-addr #{ip} #{ips_list[LEADER_INDEX]}:2377
        SCRIPT
      end unless i == LEADER_INDEX

      manager.vm.provision 'Install docker tools', type: :shell do |shell|
        shell.path = 'docker-tools.sh'
        shell.env = {
          'INSTALL_LAZYDOCKER' => 'false',
          'INSTALL_DIVE' => 'true',
          'INSTALL_PORTAINER' => 'false',
          'INSTALL_PORTAINER_SWARM' => "false",
          'INSTALL_DRY' => 'true',
          'INSTALL_TRIVY' => 'true',
          'INSTALL_HADOLINT' => 'true',
          'INSTALL_PUSHRM' => 'true',
        }
      end

      manager.vm.provision 'Wait for swarm and deploy', type: :shell, privileged: false do |shell|
        port = 8081
        manager.vm.network :forwarded_port, guest: port, host: port
        shell.env = {
          'EXPECTED_NODES' => TOTAL.to_s,
          'DOCKER_COMPOSE_FILE' => "#{SETTINGS[:SHARED_DIR]}/bgapp/docker-compose.yaml",
          'DOCKER_COMPOSE_ENV_FILE' => "#{SETTINGS[:SHARED_DIR]}/bgapp/.env",
          'STACK_NAME' => "bgapp"
        }
        shell.inline = <<~SCRIPT
          DB_SECRET=$(openssl rand -hex 16)
          echo "$DB_SECRET" | docker secret create db_root_password -

          tmux new-session -d -s deploy_stack 'bash #{SETTINGS[:SHARED_DIR]}/deploy-stack.sh; bash'
        SCRIPT
      end if i == LEADER_INDEX

      manager.trigger.before :destroy do |trigger|
        trigger.warn = 'Cleaning up'
        trigger.run = {
          inline: <<~POWERSHELL,
            if (Test-Path "manager.token") {
              Remove-Item "manager.token" -Force
            }
            if (Test-Path "worker.token") {
              Remove-Item "worker.token" -Force
            }
            if (Test-Path "wait.log") {
              Remove-Item "wait.log" -Force
            }
          POWERSHELL
        }
      end if i == LEADER_INDEX

    end
  end

  # ---------------- Define Worker Nodes ----------------
  SETTINGS[:WORKERS].times do |i|
    index = SETTINGS[:MANAGERS] + i
    name = "worker#{i + 1}"
    ip = ips_list[index]
    puts "#{ip} #{name}" if DEBUG

    config.vm.define name do |node|
      node.vm.box = SETTINGS[:BOX_NAME]
      node.vm.hostname = "#{name}.local"
      node.vm.network :private_network, ip: ip

      node.vm.provider :virtualbox do |vb|
        vb.name = name
      end

      node.vm.provision 'Join worker to swarm', type: :shell do |shell|
        puts "Joining #{name} to docker swarm" if DEBUG
        shell.inline = <<~SCRIPT
          docker swarm join --token $(cat #{SETTINGS[:SHARED_DIR]}/worker.token) --advertise-addr #{ip} #{ips_list[LEADER_INDEX]}:2377
        SCRIPT
      end

    end
  end

end